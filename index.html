<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0f1020" />
  <title>Neon Labyrinth — Minimal</title>
  <style>
    :root{
      --bg1:#0f1020; --bg2:#090a12; --panel:#13142a; --text:#e6e6f0;
      --accent:#6cf7ff; --accent2:#b46cff; --accent3:#4dff88;
      --wall:#1f2140; --glow:#86f9ff88; --safe-bottom: env(safe-area-inset-bottom);
    }
    html,body{height:100%}
    body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--text); background: radial-gradient(1000px 700px at 15% 10%, #15163a 0%, var(--bg1) 35%, var(--bg2) 100%); overflow:hidden; touch-action:none}

    .wrap{position:relative; width:100vw; height:100vh; display:grid; grid-template-rows:auto 1fr auto}

    /* Stage */
    .stage{position:relative}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block}

    /* HUD (kept only Difficulty, Left, Restart) */
    .hud{position:relative; z-index:5; display:flex; gap:12px; align-items:center; padding:10px 12px; background: color-mix(in srgb, var(--panel) 86%, transparent); backdrop-filter: blur(10px); border-radius:0 0 16px 16px; box-shadow:0 10px 30px #0006, inset 0 1px 0 #fff1; border-bottom:1px solid #ffffff14; border-left:1px solid #ffffff14; border-right:1px solid #ffffff14}
    .spacer{flex:1}
    label{font-size:12px; opacity:.85}
    select,button{appearance:none; border:none; outline:none; color:var(--text); font-weight:600}
    select{background:#0e1030; border:1px solid #ffffff18; border-radius:12px; padding:8px 12px; cursor:pointer; box-shadow: inset 0 0 0 1px #0006, 0 6px 12px #0004; font-size:14px}
    button{border-radius:12px; padding:10px 14px; cursor:pointer; background: linear-gradient(180deg, #3d9bff, #516dff); box-shadow: 0 8px 18px #0006, inset 0 1px 0 #ffffff22}
    .pill{padding:8px 10px; border-radius:999px; font-variant-numeric:tabular-nums; background:#0e1030; border:1px solid #ffffff18; box-shadow: inset 0 0 0 1px #0006; display:flex; align-items:center; gap:8px; font-size:13px}

    /* Bottom on‑screen arrows (single mode) */
    .controls{position:relative; z-index:5; padding:12px 12px calc(12px + var(--safe-bottom)); display:flex; align-items:center; justify-content:center; background: color-mix(in srgb, var(--panel) 86%, transparent); backdrop-filter: blur(8px); border-radius:16px 16px 0 0; border-top:1px solid #ffffff18; box-shadow:0 -10px 30px #0006}
    .pad{ position:relative; width:min(84vw,520px); height:min(30vh,220px); display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); gap: clamp(8px,2.5vw,16px)}
    .pad button{ border-radius:16px; font-size: clamp(18px,4.6vw,22px); width:100%; height:100%; background: linear-gradient(180deg, #2a2d66, #1b1e4e); box-shadow:0 8px 18px #0006, inset 0 1px 0 #ffffff22 }
    .pad .sp{ visibility:hidden }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div>
        <label for="difficulty">Difficulty</label>
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
          <option value="insane">Insane</option>
        </select>
      </div>
      <div class="pill"><strong>Left:</strong> <span id="left">0</span></div>
      <div class="spacer"></div>
      <button id="restart">Restart</button>
    </div>

    <div class="stage" id="stage">
      <canvas id="maze"></canvas>
      <canvas id="fx"></canvas>
    </div>

    <div class="controls">
      <div class="pad" aria-label="On-screen arrows">
        <span class="sp"></span>
        <button class="up"    data-dx="0" data-dy="-1" aria-label="Move up">▲</button>
        <span class="sp"></span>
        <button class="left"  data-dx="-1" data-dy="0" aria-label="Move left">◀</button>
        <button class="down"  data-dx="0" data-dy="1" aria-label="Move down">▼</button>
        <button class="right" data-dx="1" data-dy="0" aria-label="Move right">▶</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Utils ----------
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const now=()=>performance.now();
  const lerp=(a,b,t)=>a+(b-a)*t; const ease=t=>1-Math.pow(1-t,3);

  // ---------- Vector pet & den (simple, consistent) ----------
  function drawHead(ctx, x, y, r, a='#ffffff', b='#d8e7ff'){ const g=ctx.createRadialGradient(x-r*0.3,y-r*0.3,r*0.2,x,y,r); g.addColorStop(0,a); g.addColorStop(1,b); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
  function drawBunny(ctx,x,y,s){ const r=s*0.42; drawHead(ctx,x,y,r); ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.ellipse(x-r*0.35,y-r*1.1,r*0.28,r*0.5,-0.2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(x+r*0.35,y-r*1.1,r*0.28,r*0.5, 0.2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#263238'; ctx.beginPath(); ctx.arc(x-r*0.3,y-r*0.05,r*0.08,0,Math.PI*2); ctx.arc(x+r*0.3,y-r*0.05,r*0.08,0,Math.PI*2); ctx.fill(); }
  function drawHole(ctx,x,y,s){ ctx.save(); const g=ctx.createRadialGradient(x,y,s*0.1,x,y,s*0.6); g.addColorStop(0,'#111'); g.addColorStop(1,'#0000'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(x,y,s*0.55,s*0.36,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }

  // ---------- Maze ----------
  class Maze{ constructor(cols,rows,braid=0.35){ this.cols=cols; this.rows=rows; this.grid=Array.from({length:rows},(_,y)=>Array.from({length:cols},(_,x)=>({x,y,walls:[1,1,1,1],v:false}))); this.generate(); this.braid(braid);} cell(x,y){return (this.grid[y]||[])[x]} neighbors(x,y){return [[x,y-1,0,2],[x+1,y,1,3],[x,y+1,2,0],[x-1,y,3,1]].filter(([nx,ny])=>nx>=0&&ny>=0&&nx<this.cols&&ny<this.rows).map(([nx,ny,wi,wj])=>({from:this.cell(x,y),to:this.cell(nx,ny),wi,wj,nx,ny}))} generate(){const st=this.cell(0,0); st.v=true; const stack=[st]; while(stack.length){const cur=stack[stack.length-1]; const n=this.neighbors(cur.x,cur.y).filter(e=>!e.to.v); if(n.length){const p=n[Math.floor(Math.random()*n.length)]; cur.walls[p.wi]=0; p.to.walls[p.wj]=0; p.to.v=true; stack.push(p.to);}else stack.pop();}} braid(p){for(let y=0;y<this.rows;y++){for(let x=0;x<this.cols;x++){if(Math.random()>p)continue; const c=this.cell(x,y); const n=this.neighbors(x,y).filter(e=>c.walls[e.wi]===1); if(!n.length)continue; const pick=n[Math.floor(Math.random()*n.length)]; c.walls[pick.wi]=0; pick.to.walls[pick.wj]=0;}}} }

  const DIFFS={easy:{cols:11,rows:17,braid:0.35}, medium:{cols:15,rows:23,braid:0.35}, hard:{cols:19,rows:29,braid:0.45}, insane:{cols:25,rows:37,braid:0.5}};

  const state={diff:'medium', maze:null, player:{gx:0,gy:0,px:0,py:0,moving:false}, goal:null, moves:0, optimalMoves:0, path:[{x:0,y:0}], optimalPath:[], showOptimal:false, running:false};

  // ---------- Canvas ----------
  const mazeCv=document.getElementById('maze'), fxCv=document.getElementById('fx');
  const mctx=mazeCv.getContext('2d'), fctx=fxCv.getContext('2d');
  const stage=document.getElementById('stage');
  const DPR=()=>Math.min(2,window.devicePixelRatio||1);
  let cellSize=24, pad=16;

  function resize(){ const dpr=DPR(); const w=stage.clientWidth, h=stage.clientHeight; [mazeCv,fxCv].forEach(cv=>{cv.width=Math.floor(w*dpr); cv.height=Math.floor(h*dpr); cv.style.width=w+'px'; cv.style.height=h+'px';}); mctx.setTransform(dpr,0,0,dpr,0,0); fctx.setTransform(dpr,0,0,dpr,0,0); fitCell(); drawStatic(); }
  function fitCell(){ if(!state.maze) return; const W=stage.clientWidth-pad*2; const H=stage.clientHeight-pad*2; cellSize=Math.max(10, Math.floor(Math.min(W/state.maze.cols, H/state.maze.rows))); }
  function origin(){ const {cols,rows}=state.maze; return {ox:(stage.clientWidth-cols*cellSize)/2, oy:(stage.clientHeight-rows*cellSize)/2}; }

  // ---------- Render ----------
  function drawStatic(){ if(!state.maze) return; mctx.clearRect(0,0,mazeCv.width,mazeCv.height); const {cols,rows}=state.maze; const {ox,oy}=origin(); const g=mctx.createLinearGradient(ox,oy,ox+cols*cellSize,oy+rows*cellSize); g.addColorStop(0,'#0f1235'); g.addColorStop(1,'#14173d'); mctx.fillStyle=g; mctx.fillRect(ox-10,oy-10,cols*cellSize+20,rows*cellSize+20); mctx.lineWidth=2; mctx.strokeStyle='#9bf9ff33'; mctx.shadowColor='#86f9ff22'; mctx.shadowBlur=10; mctx.beginPath(); for(let y=0;y<rows;y++){for(let x=0;x<cols;x++){const c=state.maze.cell(x,y); const X=ox+x*cellSize, Y=oy+y*cellSize; if(c.walls[0]){mctx.moveTo(X,Y); mctx.lineTo(X+cellSize,Y);} if(c.walls[1]){mctx.moveTo(X+cellSize,Y); mctx.lineTo(X+cellSize,Y+cellSize);} if(c.walls[2]){mctx.moveTo(X,Y+cellSize); mctx.lineTo(X+cellSize,Y+cellSize);} if(c.walls[3]){mctx.moveTo(X,Y); mctx.lineTo(X,Y+cellSize);} }} mctx.stroke(); mctx.shadowBlur=0; const sx=ox+cellSize*0.5, sy=oy+cellSize*0.5; const gx=ox+(cols-0.5)*cellSize, gy=oy+(rows-0.5)*cellSize; mctx.fillStyle='#6cf7ff33'; mctx.beginPath(); mctx.arc(sx,sy,cellSize*0.33,0,Math.PI*2); mctx.fill(); drawHole(mctx,gx,gy,cellSize); if(state.showOptimal) drawOptimal(); }

  function drawTrail(){ const {ox,oy}=origin(); const pts=state.path.map(p=>({x:ox+p.x*cellSize+cellSize*0.5,y:oy+p.y*cellSize+cellSize*0.5})); pts.push({x:ox+state.player.px*cellSize+cellSize*0.5, y:oy+state.player.py*cellSize+cellSize*0.5}); fctx.save(); fctx.clearRect(0,0,fxCv.width,fxCv.height); fctx.lineJoin='round'; fctx.lineCap='round'; fctx.strokeStyle='#6cf7ff33'; fctx.lineWidth=Math.max(2,cellSize*0.28); fctx.beginPath(); pts.forEach((p,i)=> i? fctx.lineTo(p.x,p.y):fctx.moveTo(p.x,p.y)); fctx.stroke(); fctx.strokeStyle='#6cf7ffcc'; fctx.lineWidth=Math.max(2,cellSize*0.16); fctx.beginPath(); pts.forEach((p,i)=> i? fctx.lineTo(p.x,p.y):fctx.moveTo(p.x,p.y)); fctx.stroke(); fctx.restore(); }

  function drawPlayer(t){ const {ox,oy}=origin(); const cx=ox+state.player.px*cellSize+cellSize*0.5, cy=oy+state.player.py*cellSize+cellSize*0.5; const bob=Math.sin(t/240)*Math.min(6,cellSize*0.12); drawTrail(); // shadow
    fctx.save(); fctx.fillStyle='#00000030'; fctx.beginPath(); fctx.ellipse(cx, cy+cellSize*0.18, cellSize*0.24, cellSize*0.12, 0, 0, Math.PI*2); fctx.fill(); fctx.restore(); drawBunny(fctx, cx, cy+bob, cellSize); }

  function drawOptimal(){ const {ox,oy}=origin(); if(!state.optimalPath.length) return; mctx.save(); mctx.lineCap='round'; mctx.lineJoin='round'; mctx.strokeStyle='#ffde5bcc'; mctx.lineWidth=Math.max(2,cellSize*0.18); mctx.beginPath(); state.optimalPath.forEach((p,i)=>{const x=ox+p.x*cellSize+cellSize*0.5, y=oy+p.y*cellSize+cellSize*0.5; i? mctx.lineTo(x,y):mctx.moveTo(x,y);}); mctx.stroke(); mctx.restore(); }

  // ---------- Input (keyboard + buttons) ----------
  const KEYMAP={ArrowUp:[0,-1],ArrowRight:[1,0],ArrowDown:[0,1],ArrowLeft:[-1,0],KeyW:[0,-1],KeyD:[1,0],KeyS:[0,1],KeyA:[-1,0]};
  window.addEventListener('keydown',e=>{ if(!state.running) return; const d=KEYMAP[e.code]; if(!d) return; e.preventDefault(); tryMove(d[0],d[1]); });
  document.querySelectorAll('.pad button').forEach(b=> b.addEventListener('click',()=>{ if(!state.running) return; tryMove(+b.dataset.dx,+b.dataset.dy); }));

  // ---------- Moves ----------
  function tryMove(dx,dy){ if(state.player.moving) return; const c=state.maze.cell(state.player.gx,state.player.gy); const dir = dx===0&&dy===-1?0:dx===1&&dy===0?1:dx===0&&dy===1?2:3; if(c.walls[dir]) return; moveTo(state.player.gx+dx, state.player.gy+dy); }
  function moveTo(nx,ny){ state.player.moving=true; state.moves++; updateLeft(); const sx=state.player.gx, sy=state.player.gy; const t0=now(), dur=140; const step=()=>{ const k=Math.min(1,(now()-t0)/dur), e=ease(k); state.player.px=lerp(sx,nx,e); state.player.py=lerp(sy,ny,e); if(k<1) requestAnimationFrame(step); else { state.player.gx=nx; state.player.gy=ny; state.player.px=nx; state.player.py=ny; state.player.moving=false; const L=state.path.length; if(L>=2 && state.path[L-2].x===nx && state.path[L-2].y===ny) state.path.pop(); else state.path.push({x:nx,y:ny}); checkWin(); } }; step(); }

  // ---------- Shortest path ----------
  function shortestPath(){ const {cols,rows}=state.maze; const goal={x:cols-1,y:rows-1}; const dist=Array.from({length:rows},()=>Array(cols).fill(Infinity)); const prev=Array.from({length:rows},()=>Array(cols).fill(null)); const q=[{x:0,y:0}]; dist[0][0]=0; while(q.length){ const {x,y}=q.shift(); if(x===goal.x && y===goal.y) break; const c=state.maze.cell(x,y); const neigh=[[0,-1,0],[1,0,1],[0,1,2],[-1,0,3]]; for(const [dx,dy,wi] of neigh){ const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=cols||ny>=rows) continue; if(c.walls[wi]) continue; const nc=state.maze.cell(nx,ny); const wj=(wi+2)%4; if(nc.walls[wj]) continue; if(dist[ny][nx]===Infinity){ dist[ny][nx]=dist[y][x]+1; prev[ny][nx]={x,y}; q.push({x:nx,y:ny}); } } }
    // reconstruct
    const path=[]; let cur={x:goal.x,y:goal.y}; if(dist[cur.y][cur.x]===Infinity) return {len:Infinity, path:[]}; while(cur){ path.push(cur); cur=prev[cur.y][cur.x]; } path.reverse(); return {len:dist[goal.y][goal.x], path}; }

  // ---------- UI ----------
  const leftEl=document.getElementById('left');
  function updateLeft(){ leftEl.textContent = state.optimalMoves - state.moves; }

  document.getElementById('difficulty').addEventListener('change', e=>{ state.diff=e.target.value; newMaze(); });
  document.getElementById('restart').addEventListener('click', restart);

  // ---------- Game flow ----------
  function newMaze(){ const d=DIFFS[state.diff]; state.maze=new Maze(d.cols,d.rows,d.braid); fitCell(); state.player={gx:0,gy:0,px:0,py:0,moving:false}; state.goal={x:state.maze.cols-1,y:state.maze.rows-1}; state.path=[{x:0,y:0}]; const sp=shortestPath(); state.optimalMoves=sp.len; state.optimalPath=sp.path; state.moves=0; state.showOptimal=false; updateLeft(); drawStatic(); state.running=true; }
  function restart(){ state.player={gx:0,gy:0,px:0,py:0,moving:false}; state.path=[{x:0,y:0}]; state.moves=0; state.showOptimal=false; updateLeft(); }
  function checkWin(){ if(state.player.gx===state.goal.x && state.player.gy===state.goal.y){ state.running=false; if(state.moves>state.optimalMoves){ state.showOptimal=true; drawStatic(); } } }

  // ---------- Loop ----------
  let last=now(); function loop(){ const t=now(); last=t; drawStatic(); drawPlayer(t); requestAnimationFrame(loop); }

  // ---------- Self tests ----------
  function selfTests(){ const sp=shortestPath(); console.assert(Number.isFinite(sp.len) && sp.len>0, 'BFS shortest path exists'); }

  window.addEventListener('resize', resize);
  resize(); newMaze(); selfTests(); loop();
})();
</script>
</body>
</html>

